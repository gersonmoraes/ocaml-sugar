<!DOCTYPE html>
<html>
  <head>
    <title>OCaml Sugar</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Roboto+Condensed:300,600,400italic);
      @import url(https://fonts.googleapis.com/css?family=Josefin+Sans:300,700,400italic);

      body { font-family: 'Roboto Condensed', sans-serif; }
      h1, h2, h3 {
        font-family: 'Josefin Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
<textarea id="source" hidden="true">


class: right, middle

background-image: url(https://www.ocamlplace.com/assets/pexels-photo-352779.jpeg)
background-size: cover

# OCaml Sugar

A peek into the future of Functional Programming

<small>*Gerson Moraes*</small>

---
class: left, middle
background-color: #E3E2DE

# What it is

A **Model Driven Development** library that allows you to:

- Write code using modern FP techniques
- Produce clean code using error-aware expressions everywhere
- Write DSLs that are modular and composable by design

---

class: left, middle
background-color: #E3E2DE

# Lean and Clean

**Safer computations**

Exceptions are easy to write and easier to forget. Better to avoid them. Sugar encourages you to define your error types early on, and always be ready for failures.

**One interface to rule them all**

Using meta programming, all our error aware expressions, *asynchronous or not*, will keep the same clean look. Let the machine translate the result types. *Focus on the real stufff*.

---
class: left, middle

# Custom-build for your project

Set up an isolated module for your errors.
```ocaml
module Errors = struct
  type t = AlreadyExists | Not_found
end
```
<br/>

And feed it to a *result module builder* to start coding:
```ocaml
module Result = Sugar.Result.Make (Errors)
open Result

let main () : unit result =
  do_something ()
  >>= fun res ->
  do_something_else res

```

---

# Add your error handlers

With exceptions, you'd normally use a `try...with` block like:

```ocaml
let program () =
  try
    do_something ()
  with
  | AlreadyExists -> print_endline "recoverd"
  | Not_found     -> print_endline "recoverd"
```
<br/>

---

# Add your error handlers

With exceptions, you'd normally use a `try...with` block like:

```ocaml
let program () =
  try
    do_something ()
  with
  | AlreadyExists -> print_endline "recoverd"
  | Not_found     -> print_endline "recoverd"
```
<br/>

The same can be done with error aware expressions:

```ocaml
let program () =
  do_something ()
  >---------
  ( function
    | AlreadyExists -> puts "recoverd"
    | Not_found     -> puts "recoverd"
  )
```

---
background-image: url(https://www.ocamlplace.com/assets/measurement-millimeter-centimeter-meter-162500.jpeg)
background-size: cover

# Not just aesthetics

Yep, it's a huge *10-char long* operator. But...

---
background-image: url(https://www.ocamlplace.com/assets/measurement-millimeter-centimeter-meter-162500.jpeg)
background-size: cover

# Not just aesthetics

Yep, it's a huge *10-char long* operator. But...

Did you notice the hidden message?

---

# Clean your errors with a block

This broom shaped combinator has the exact minimum char count for the next expression: *an anonymous function wrapped inside a block*.

The same goes for the other syntax for anonymous functions:

```ocaml
let program () =
  do_something ()
  >---------
  ( fun e ->
    puts "recoverd"
  )
```

---

# Why this matters

- Anonymous functions have *gigantic scope*.
- Using them to write alternative control flows can be misleading
- You *want* a block around every error handler.

---

# Why this matters

- Anonymous functions have *gigantic scope*.
- Using them to write alternative control flows can be misleading
- You *want* a block around every error handler.

<br/>
What would be printed?

```ocaml
let puts s =
  print_endline s;
  return ()

let program () =
  puts "hello"
  >---------
  fun e ->
  return ()
  >>= fun () ->
  puts "world"
```
---

# Why this matters

- Anonymous functions have *gigantic scope*.
- Using them to write alternative control flows can be misleading
- You *want* a block around every error handler.

<br/>
What about now?

```ocaml
let puts s =
  print_endline s;
  return ()

let program () =
  puts "hello"
  >---------
  ( fun e ->
    return ()
  )
  >>= fun () ->
  puts "world"
```

*Tip*: The programs have different outputs
---

background-color: #E3E2DE
class: left, middle

# Way more than that

A short path towards composable DSLs with **The Free Monad**. Don't write a program, write a description of a program. Since it's your description, you can decide how to interpret it, and in how many ways.

It's your chance to easily swap core components of your projects, separate business logic from things like logging and cloud services. You can write integration tests that are easy to reason about.

---

# Composable DSLs

1. Abstract concepts
 1. Functors, Monads and The Free Monad
 2. Continuations

2. DSL Writer Tour
 1. Bare Bones
 2. Code Generation
 3. Define a Public Api
 4. Contexts

3. Library Writer Tour
 1. Combining Languages
 2. Assembling Runtimes
 3. Partially implemented DSLs

4. Conclusion


---
class: left, middle
background-color: #E3E2DE

# Abstract concepts

**Funtors**, **Monads** and **Free Monads** matter. You should probably learn about them. But this knowledge is not essential to write DSLs, since a basic OCaml undertanding is sufficient to get you started.

A **Continuation** is a fancy word to name a callback. It is a function stored for later, hopefully to be run at some point.


---
class: left, top

# More on Continuations

**Watching the next instruction**

To write a DSL, you need to describe *(and implement)* each instruction separately. One crucial information about an instruction is what value it should return back to the caller. This is defined by specifying the next continuation in the chain.

To help you do that, use the `next` type:

```ocaml
type ('f, 'args) next = 'args -> 'f
```

<br/>
Can you guess the meaning of each type of continuation bellow?

```ocaml
type 'f instruction =
  | A of ('f, string) next
  | B of ('f, int option) next
  | C of ('f, bool -> bool -> bool) next
```

---
class: left, top

# More on Continuations

**Unrelated continuations**

If your expression doesn't return any useful value, you could use the `unrelated` type alias:

```ocaml
type 'f unrelated = ('f, unit) next
```

<br/>
In the example bellow, `A` and `B` have the same singnature for the next continuation.

```ocaml
type 'f instruction =
  | A of ('f, unit) next
  | B of 'f unrelated
```

---
class: left, middle
background-color: #E3E2DE

# DSL Writer Tour

In the next slides, we will describe the minimum steps to create a small `Terminal` DSL.

We will go over the main conventions, meta programming, and the few things you
need to do so other people can safely use your DSL.

---

# DSL Writer Tour - Part I

**Bare Bones**

- Describe your core instructions
- Write a `map` function
- Specify your errors

---

# DSL Writer Tour - Part I

**Bare Bones**

- **Describe your core instructions**
- Write a `map` function
- Specify your errors

<br/>

----

We need two instructions in the Terminal.

```ocaml
module Terminal = struct

  module Algebra = struct
    type 'f t
      = Puts of string * ('f unrelated)
      | GetLine of ('f, string result) next
  end

end
```

---

# DSL Writer Tour - Part I

**Bare Bones**

- ~~**Describe your core instructions**~~
- **Write a `map` function**
- Specify your errors

<br/>

----

This is how the compiler will know how to store and iterate over the instructions.

```ocaml
module Terminal = struct

  module Algebra = struct
    ...

    let map f = function
      | Puts (s, g) -> Puts (s, f @ g)
      | GetLine g -> GetLine (f @ g)
  end

end
```

---

# DSL Writer Tour - Part I

**Bare Bones**

- ~~**Describe your core instructions**~~
- ~~**Write a `map` function**~~
- **Specify your errors**

<br/>

----

Don't forget to make your errors serializable using s-expressions.

```ocaml
open Sexplib.Std

module Terminal = struct
  ...

  module Errors = struct
    type t
      = Not_available
      | Unexpected of string [@@deriving sexp]
  end

end
```


---

# DSL Writer Tour - Part II

**Code Generation**

- Make your errors compatible with other DSLs
- Create a specification for this DSL

---

# DSL Writer Tour - Part II

**Code Generation**

- **Make your errors compatible with other DSLs**
- Create a specification for this DSL

<br/>

----

This will create a new `Error` constructor for a shared open type. It will
be accessible only using the full namespaced name of your DSL, which in this case is `Terminal.Error`.

It will also create a `string_of_error` function.

```ocaml
module Terminal = struct
  ...

  include Sugar.DSL.ErrorFor(Errors)
end
```

---

# DSL Writer Tour - Part II

**Code Generation**

- ~~**Make your errors compatible with other DSLs**~~
- **Create a specification for this DSL**

<br/>

----

A `Spec` module gives you interoperability signatures and builders so your DSL can became pluggable.

```ocaml
module Terminal = struct
  ...

  module Spec = Sugar.DSL.SpecFor(Algebra)
end
```
---

# DSL Writer Tour - Part III

**Define a Public Api**

- Write a public module for your users
- Understand how contexts work
- Instantiate your own Public Api


---

# DSL Writer Tour - Part III

**Define a Public Api**

- **Write a public module for your users**
- Understand how contexts work
- Instantiate your own Public Api

<br/>

----

This will be the only requirement for anyone to use your DSL.

```ocaml
module Terminal = struct
  ...

  module New (C:Spec.S.Context) = struct
    open C

    let puts s =
      Puts (s, id) |> lift

    let get_line () =
      GetLine id |> lift
  end
end
```

---

# DSL Writer Tour - Part III

**Define a Public Api**

- ~~**Write a public module for your users**~~
- **Understand how contexts work**
- Instantiate your own Public Api

---

class: left, middle
background-color: #E3E2DE

# Contexts

The guys responsible for translating instructions from current the language to a bigger one, used to build the final runtime. They are the glue that allows you to mix different DSLs.

Under the hood, they implement a natural transformation.


---

# DSL Writer Tour - Part III

**Define a Public Api**

- ~~**Write a public module for your users**~~
- ~~**Understand how contexts work**~~
- **Instantiate your own Public Api**

<br/>

----

If you just have one DSL, use the default builder to create a context. Instantiating a DSL's Public Api is also straightforward.

```ocaml
module Context = Sugar.DSL.ContextFor(Terminal.Algebra)

module MyTerminal = Terminal.New (Context)
```

---

# DSL Writer Tour - Part III

**Define a Public Api**

- ~~**Write a public module for your users**~~
- ~~**Understand how contexts work**~~
- **Instantiate your own Public Api**

<br/>

----

```ocaml
open MyTerminal
open Context
open Context.Infix

let program () =
  puts "What's your name?" >>
  get_line ()
  >>= fun name ->
  puts (name ^ ", have a nice day.")
  >---------
  ( function
    Terminal.Error e -> puts ("recovered from "^(Terminal.string_of_error e))
    _ -> assert false
  )
```

---

class: left, middle
background-color: #E3E2DE

# What if you need to combine different DSLs?

The process is quite similar. Hold tight.

---

# Combining DSLs

Say you have two DSLs.

```ocaml
module X = struct
  module Errors = struct
    type t = Not_found [@@deriving sexp]
  end
  module Algebra = struct
    type 'f t = A of 'f unrelated
    let map f = function
      | A g -> A (f @ g)
  end
  ...
end
```

```ocaml
module Y = struct
  module Errors = struct
    type t = Not_available [@@deriving sexp]
  end
  module Algebra = struct
    type 'f t = B of 'f unrelated
    let map f = function
      | B g -> B (f @ g)
  end
  ...
end
```

---

# Combining DSLs

Each one with its own `New` module.

```ocaml
module X = struct
  ...
  module New (C:Spec.S.Context) = struct
    let a () =
      A id |> C.lift
  end
end
```

```ocaml
module Y = struct
  ...
  module New (C:Spec.S.Context) = struct
    let b () =
      b id |> C.lift
  end
end
```


---

# Combining DSLs

To use `X` and `Y` together, you need to combine both core instructions and Public Apis.

```ocaml
module X_and_Y = struct
  include Sugar.DSL.Combine (X.Algebra) (Y.Algebra)

  module New (C:Spec.S.Context) = struct
    include X.New (Natural.Proxy1.For(Ctx))
    include Y.New (Natural.Proxy2.For(Ctx))
  end
end
```

---

# Combining DSLs

To use `X` and `Y` together, you need to combine both core instructions and Public Apis.

```ocaml
module X_and_Y = struct
  include Sugar.DSL.Combine (X.Algebra) (Y.Algebra)

  module New (C:Spec.S.Context) = struct
    include X.New (Natural.Proxy1.For(Ctx))
    include Y.New (Natural.Proxy2.For(Ctx))
  end
end
```

<br/>

From this point on, you can start coding.

```ocaml
module Context = Sugar.DSL.ContextFor(X_and_Y.Algebra)
module MyLib = X_and_Y.New (Context)

open MyLib
open Context.Infix

let program () =
   a () >>
   b ()
```


---

class: left, middle
background-color: #E3E2DE

# Interpreters

So far we've learned how to describe programs. How about running them?

---

# Interpreters

Every DSL comes with a signature for its `Runner`.

```ocaml
module Spec = struct
  ...
  module type Runner = sig
    val run: 'a Algebra.t -> 'a
    val debug: 'a Algebra.t -> 'a
  end
end
```

---

# Interpreters

Every DSL comes with a signature for its `Runner`.

```ocaml
module Spec = struct
  ...
  module type Runner = sig
    val run: 'a Algebra.t -> 'a
    val debug: 'a Algebra.t -> 'a
  end
end
```


The default interpreter is the `run` function.The `debug` function should do virtually the same with higher verbosity. You are not forced to follow this structure in your code base, but we believe it is an expressive one.

Notice how a runner only knows about its core instructions. This holds even if you mix different DSLs and is the reason there is a clear separation of concerns when writing DSLs.

---

# Interpreters

Here's a runner for the `Terminal` DSL:

```ocaml
module TerminalRunner = struct

  open Terminal.Algebra

  let run = function
    | Puts (s, f) -> print_endline s; return () |> f
    | GetLine f -> read_line () |> return |> f

  let debug = function
    | Puts (s, f) ->
        print_endline ("Puts: " ^ s); return () |> f
    | GetLine f ->
        Printf.printf "GetLine: ";
        read_line () |> return |> f
end
```

---

# Interpreters

Combined DSLs also need a Runner.

```ocaml
module X_and_Y_Runner = struct
  open X_and_Y.Algebra

  let run = function
    | Case1 (X.Algebra.A f) -> f ()
    | Case2 (Y.Algebra.B f) -> f ()

  let debug = function
    | Case1 (X.Algebra.A f) -> print_endline "X.A: "; f ()
    | Case2 (Y.Algebra.B f) -> print_endline "X.B: "; f ()
end
```

---

# Interpreters

Combined DSLs also need a Runner.

```ocaml
module X_and_Y_Runner = struct
  open X_and_Y.Algebra

  let run = function
    | Case1 (X.Algebra.A f) -> f ()
    | Case2 (Y.Algebra.B f) -> f ()

  let debug = function
    | Case1 (X.Algebra.A f) -> print_endline "X.A: "; f ()
    | Case2 (Y.Algebra.B f) -> print_endline "X.B: "; f ()
end
```

<br/>

You can use this runners with the context to run programs:

```ocaml
let () =
  Context.run_error_aware Terminal.Runner.debug program
```

---
class: left, middle
background-color: #E3E2DE

# Scaling with runtimes

If you are combining many DSLs that you already know how to run, you can wrap them
together and manage them as a unit. We call this a `Runtime` inside Sugar.

The fun part is that runtimes can be assambled together too.

---

# Runtimes

A runtime have a signature very similar to the DSL module we've seen before,
plus a runner.

```ocaml
module type Runtime = sig
  module Algebra : Functor
  module Spec : Spec with module Algebra = Algebra
  module Runner : sig
    val run : 'a Algebra.t -> 'a
    val debug : 'a Algebra.t -> 'a
  end
end
```

---

# Runtimes

A runtime have a signature very similar to the DSL module we've seen before,
plus a runner.

```ocaml
module type Runtime = sig
  module Algebra : Functor
  module Spec : Spec with module Algebra = Algebra
  module Runner : sig
    val run : 'a Algebra.t -> 'a
    val debug : 'a Algebra.t -> 'a
  end
end
```

<br/>
Combining runtimes instead of just the core modules have advantage of reusing
the known runners. We call this operation `Assembly` inside Sugar.


---

# Runtimes

For example, if the DSLs `X` and `Y` from the previous examples came with default
runners, with could merge them together with:

```ocaml
module XY = struct
  include Assembly (X) (Y)

  module New (C:Spec.S.Context) = struct
    include X.New (Natural.Proxy1.For(C))
    include Y.New (Natural.Proxy2.For(C))
  end
end

Context = Sugar.DSL.ContextForRuntime(X_and_Y)

...

let () =
  Context.run_error_aware XY.Runner.debug program_for_xy
```
---

class: center, middle
background-color: #E3E2DE


# Conclusion

You have new tools to build DSLs in OCaml.

Have fun with the language.



</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>

    <!--
        Isso foi adicionado para compatibilidade com "LiveReload no Atom"
        Inicie o servidor local com Ctrl-Shift-R.
        Nota:
        Pode ser necessÃ¡rio atualizar a porta indicada na barra de status.
    -->
    <script src="http://localhost:35729/livereload.js">
    </script>
  </body>
</html>
