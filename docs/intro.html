<!DOCTYPE html>
<html>
  <head>
    <title>OCaml Sugar</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Roboto+Condensed:300,600,400italic);
      @import url(https://fonts.googleapis.com/css?family=Fjalla+One:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Josefin+Sans:300,700,400italic);

      /*body { font-family: 'Droid Serif'; }*/
      body { font-family: 'Roboto Condensed', sans-serif; }
      h1, h2, h3 {
        font-family: 'Josefin Sans';
        /*font-family: 'Yanone Kaffeesatz';*/
        /*font-family: 'Fjalla One';*/
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
<textarea id="source" hidden="true">


class: right, middle

background-image: url(https://www.ocamlplace.com/assets/pexels-photo-352779.jpeg)
background-size: cover

# OCaml Sugar

A peek into the future of Functional Programming

<small>*Gerson Moraes*</small>

---
class: left, middle
background-color: #E3E2DE

# What it is

A **Model Driven Development** library that allows you to:

- Write code using modern FP techniques
- Produce clean code using error-aware expressions everywhere
- Write DSLs that are modular and composable by design

---

class: left, middle
background-color: #E3E2DE

# Lean and Clean

**Safer computations**

Exceptions are easy to write and easier to forget. Better to avoid them. Sugar encourages you to define your error types early on, and always be ready for failures.

**One interface to rule them all**

Using meta programming, all our error aware expressions, *asynchronous or not*, will keep the same clean look. Let the machine translate the result types. *Focus on the real stufff*.

---
class: left, middle

# Custom-build for your project

Set up an isolated module for your errors.
```ocaml
module MyError = struct
  type t = AlreadyExists | Not_found
end
```
<br/>

And feed it to a *result module builder* to start coding:
```ocaml
module MyResult = Sugar.Result.Make (MyError)
open MyResult

let main () : string result =
  do_something ()
  >>= fun res ->
  run_computation res >>
  return "hello world"

```

---

# Add your error handlers

With exceptions, you'd normally use a `try...with` block like:

```ocaml
let program () =
  try
    do_something ()
  with
  | AlreadyExists -> print_endline "recoverd"
  | Not_found     -> print_endline "recoverd"
```
<br/>

---

# Add your error handlers

With exceptions, you'd normally use a `try...with` block like:

```ocaml
let program () =
  try
    do_something ()
  with
  | AlreadyExists -> print_endline "recoverd"
  | Not_found     -> print_endline "recoverd"
```
<br/>

The same can be done with error aware expressions:

```ocaml
let program () =
  do_something ()
  >---------
  ( function
    | AlreadyExists -> puts "recoverd"
    | Not_found     -> puts "recoverd"
  )
```

---
background-image: url(https://www.ocamlplace.com/assets/measurement-millimeter-centimeter-meter-162500.jpeg)
background-size: cover

# Not just aesthetics

Yep, it's a huge *10-char long* operator. But...

---
background-image: url(https://www.ocamlplace.com/assets/measurement-millimeter-centimeter-meter-162500.jpeg)
background-size: cover

# Not just aesthetics

Yep, it's a huge *10-char long* operator. But...

Did you notice the hidden message?

---

# A hidden message

<u>You need to clean your errors with a block.</u>

This broom shaped combinator has the exact minimum char count for the next expression: *an anonymous function wrapped inside a block*.

The same goes for the other syntax for anonymous functions:

```ocaml
let program () =
  do_something ()
  >---------
  ( fun e ->
    puts "recoverd"
  )
```

---

# Why this matters

- Anonymous functions have *gigantic scope*.
- Using them to write alternative control flows can be misleading
- You *want* a block around every error handler.

---

# Why this matters

- Anonymous functions have *gigantic scope*.
- Using them to write alternative control flows can be misleading
- You *want* a block around every error handler.

<br/>
*What would be printed?*

```ocaml
let puts s =
  print_endline s;
  return ()

let program () =
  puts "hello"
  >---------
  fun e ->
  return ()
  >>= fun () ->
  puts "world"
```
---

# Why this matters

- Anonymous functions have *gigantic scope*.
- Using them to write alternative control flows can be misleading
- You *want* a block around every error handler.

<br/>
*What about now?*

```ocaml
let puts s =
  print_endline s;
  return ()

let program () =
  puts "hello"
  >---------
  ( fun e ->
    return ()
  )
  >>= fun () ->
  puts "world"
```

*Tip*: The programs have different outputs
---

background-color: #E3E2DE
class: left, middle

# Way more than that

A short path towards composable DSLs with **The Free Monad**. Don't write a program, write a description of a program. Since it's your description, you can decide how to interpret it, and in how many ways.

It's your chance to easily swap core components of your projects,
separate business logic from logging and cloud services. You can write integration
tests that are easy to reason about.

---

# Composable DSLs

1. Abstract concepts
 1. Functors, Monads and The Free Monad
 2. Continuations

2. DSL Writer Tour
 1. Bare Bones
 2. Meta Programming
 3. Public Api Module

3. DSL Library Writer
 1. Combining Languages
 2. Assembling Runtimes
 3. Partially implemented DSLs

4. Conclusion


---
class: left, middle
background-color: #E3E2DE

# Abstract concepts

**Funtors**, **Monads** and **Free Monads** matter. You should probably learn about them. But this knowledge is not essential to write DSLs, since a basic OCaml undertanding is sufficient to get you started.

A **Continuation** is a fancy word to name a callback. It is a function stored for later, hopefully to be run at some point.


---
class: left, top

# More on Continuations

**Watching the next instruction**

To write a DSL, you need to describe *(and implement)* each instruction separately. One crucial information about an instruction is what value it should return back to the caller. This is defined by specifying the next continuation in the chain.

To help you do that, use the `next` type:

```ocaml
type ('f, 'args) next = 'args -> 'f
```

<br/>
Can you guess the meaning of each type of continuation bellow?

```ocaml
type 'f instruction =
  | A of ('f, string) next
  | B of ('f, int option) next
  | C of ('f, bool -> bool -> bool) next
```

---
class: left, top

# More on Continuations

**Unrelated continuations**

If your expression doesn't return any useful value, you could use the `unrelated` type alias:

```ocaml
type 'f unrelated = ('f, unit) next
```

<br/>
In the example bellow, `A` and `B` have the same singnature for the next continuation.

```ocaml
type 'f instruction =
  | A of ('f, unit) next
  | B of 'f unrelated
```

---
class: left, middle
background-color: #E3E2DE

# Interfaces for DSL writers

In the next slides, we will describe the minimum steps to create a small Terminal DSL.

We will go over the main conventions, meta programming, and the few things you
need to do so other people can safely use your DSL.

---

# DSL Writer Tour - Part I

**Bare Bones**

- Describe your core instructions
- Write a `map` function
- Specify your errors

---

# DSL Writer Tour - Part I

**Bare Bones**

- **Describe your core instructions**
- Write a `map` function
- Specify your errors

<br/>

----

We are defining just two instructions: Puts and GetLine.

```ocaml
module Terminal = struct

  module Core = struct
    type 'f t
      = Puts of string * ('f unrelated)
      | GetLine of ('f, string result) next
  end

end
```

---

# DSL Writer Tour - Part I

**Bare Bones**

- ~~**Describe your core instructions**~~
- **Write a `map` function**
- Specify your errors

<br/>

----

This is how the compiler will know how to store and iterate over instructions on our programs.

```ocaml
module Terminal = struct

  module Core = struct
    ...

    let map f = function
      | Puts (s, g) -> Puts (s, f @ g)
      | GetLine g -> GetLine (f @ g)
  end

end
```

---

# DSL Writer Tour - Part I

**Bare Bones**

- ~~**Describe your core instructions**~~
- ~~**Write a `map` function**~~
- **Specify your errors**

<br/>

----

Don't forget to make your errors serializable using s-expressions.

```ocaml
open Sexplib.Std

module Terminal = struct
  ...

  module Errors = struct
    type t
      = Not_available
      | Unexpected of string [@@deriving sexp]
  end

end
```


---

# DSL Writer Tour - Part II

**Meta Programming**

- Integrate your errors with Sugar
- Create a specification for this DSL
- Write a public module for your users

---

# DSL Writer Tour - Part II

**Meta Programming**

- **Integrate your errors with Sugar**
- Create a specification for this DSL
- Write a public module for your users

<br/>

----

This will get you an `Error` constructor to wrap around your door specification. It will also add a `string_of_error` function.

```ocaml
module Terminal = struct
  ...

  include Sugar.DSL.ErrorFor(Errors)
end
```

---

# DSL Writer Tour - Part II

**Meta Programming**

- ~~**Integrate your errors with Sugar**~~
- **Create a specification for this DSL**
- Write a public module for your users

<br/>

----

A `Spec` module gives you essential interoperability signatures and builders so your Dsl can became pluggable.

```ocaml
module Terminal = struct
  ...

  module Spec = Sugar.DSL.SpecFor(Core)
end
```
---

# DSL Writer Tour - Part II

**Meta Programming**

- ~~**Integrate your errors with Sugar**~~
- ~~**Create a specification for this DSL**~~
- **Write a public module for your users**

<br/>

----

This will be the only requirement for anyone to use your DSL.

```ocaml
module Terminal = struct
  ...

  module Api (Ctx:Spec.S.Context) = struct
    let puts s =
      Puts (s, id) |> Ctx.lift

    let get_line () =
      GetLine id |> Ctx.lift
  end
end
```

---

# DSL Writer Tour - Part II

**Meta Programming**

- ~~**Integrate your errors with Sugar**~~
- ~~**Create a specification for this DSL**~~
- ~~**Write a public module for your users**~~

<br/>

----

But, what is a `context` and how can you get one?

---

class: left, middle
background-color: #E3E2DE

# A context is

A module responsible for the translation of core instructions from current the language to the bigger language used to build the final runtime. They can be seem as the glue that allows you to mix different DSLs.

Under the hood, it is how Sugar implements natural transformations to make languages 


---

# DSL Writer Tour - Part II

**Public Api (example)**

Let's finish the specification of our Terminal Dsl.
It uses two helper functions to "instanciate" each instruction:

- **id**: return the next continuation
- **lift**: *store the instruction for later*. This instruction will be "stored" in the Free Monad main type.


```ocaml
module Terminal = struct
  ...

  module Api (Ctx:Spec.S.Context) = struct

    let puts s =
      Puts (s, id) |> Ctx.lift

    let get_line () =
      GetLine id |> Ctx.lift

  end
end
```

---
class: center, middle


# Conclusion

...



</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>

    <!--
        Isso foi adicionado para compatibilidade com "LiveReload no Atom"
        Inicie o servidor local com Ctrl-Shift-R.
        Nota:
        Pode ser necessÃ¡rio atualizar a porta indicada na barra de status.
    -->
    <script src="http://localhost:35729/livereload.js">
    </script>
  </body>
</html>
