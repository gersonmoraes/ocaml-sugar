<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>NoExceptions (sugar.Sugar__S.Strict_result.NoExceptions)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../../index.html">sugar</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Sugar__S.Strict_result.NoExceptions</span></h1></header><div class="doc"><p>Disable exception handling</p></div><div class="spec include"><div class="doc"></div><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../../index.html#module-type-Result_partials">Result_partials</a></code></span></summary><div class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>error</code><code></code><code></code></div><div class="doc"><p>Error definition from your project</p></div></div><div class="spec type" id="type-result"><a href="#type-result" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a result</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, <a href="index.html#type-error">error</a>) Result.result</code><code></code></div><div class="doc"><p>An alias for the result type in the stdlib</p></div></div><div class="spec val" id="val-bind"><a href="#val-bind" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>bind : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a></code></div><div class="doc"><p>Apply the binding only if the computation was successful.
You can use the operator <a href="index.html#val-(&gt;&gt;=)">&gt;&gt;=</a> instead of this function for syntatic sugar</p></div></div><div class="spec val" id="val-bind_unless"><a href="#val-bind_unless" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>bind_unless : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-error">error</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></div><div class="doc"><p>Apply the binding only if the computation failed.</p><p>Notice that an error handler must be provided, and this handler
must throw an error or provide an equivalent for the result type of the
previous computation.</p><p>You can use the operator <a href="Infix/index.html#val-(&gt;---------)">&gt;---------</a> instead of this function for syntatic sugar</p></div></div><div class="spec val" id="val-map"><a href="#val-map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>map : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a></code></div><div class="doc"><p>Apply a function to the result of a successful computation. This function
makes it ease to work with non error aware functions.</p><p>Example:
</p><pre><code class="code">
    open Sugar.Option

    let twenty =
     map (Some 10) (fun n -&gt; n + n)
    </code></pre><p>You could also use the combinator <a href="Infix/index.html#val-(&gt;&gt;|)">&gt;&gt;|</a> for syntatic sugar.</p></div></div><div class="spec val" id="val-return"><a href="#val-return" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>return : <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></div><div class="doc"><p>Return a value in a successful computation.
This function should be used with its counterpart, <code class="code">throw</code></p></div></div><div class="spec val" id="val-throw"><a href="#val-throw" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>throw : <a href="index.html#type-error">error</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></div><div class="doc"><p>Return an error as the result of a computation.</p><p>Like the <code class="code">return</code> function, <code class="code">throw</code> helps you hide the internals of your
result type and keep a clean code.</p><p>If you are still at the beginning of your project, and don't have your
errors defined yet, this function still is a great help. For example,
the code bellow have the same usage as the function <code class="code">failwith</code>, but is a lot
safer.</p><pre><code class="code">
     module MyResult = Sugar.MakeResult (struct error = string end)
     open MyResult
     let run (): int result =
       if true then
         return 10
       else
         throw &quot;something bad happend&quot;
    </code></pre><p>You could also not describe your errors at all for some time, and
use the <a href="../../../Sugar/Option/index.html">Sugar.Option</a> module to create error aware computations, like:</p><pre><code class="code">
     open Sugar.Option
     let run (): string result =
       if true then
         return &quot;hello world&quot;
       else
         throw ()
    </code></pre></div></div><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec val" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a></code></div><div class="doc"><p>Bind combinator</p><p>If the computation in the left is successful, the operator will
Take the inner value and feed it to the function in the right. This is an
alias for the function <code class="code">bind</code>.</p><p>If the computation in the left failed, the operator will propagate the error,
skipping the function completely.</p></div></div><div class="spec val" id="val-unwrap"><a href="#val-unwrap" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>unwrap : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p>Unwraps the successful result as a normal value in the threading monad.
If the value is not successful, it will raise an Invalid_arg exception.</p></div></div><div class="spec val" id="val-unwrap_or"><a href="#val-unwrap_or" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>unwrap_or : (<a href="index.html#type-error">error</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p>Unwraps the successful result as a value in the threading monad.
Different from <code class="code">unwrap</code>, you can assign an error handler to be
executed if the computation failed. Example:
</p><pre><code class="code">
    let run () =
      get_data ()
      |&gt; unwrap_or (fun _ -&gt; &quot;default&quot;)
    </code></pre></div></div><div class="spec val" id="val-expect"><a href="#val-expect" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>expect : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p>Extracts a successful value from an computation, or raises and Invalid_arg
exception with the defined parameter.</p></div></div></details></div><div class="spec module" id="module-For"><a href="#module-For" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="For/index.html">For</a> : <span class="keyword">functor</span> (<a href="For/argument-1-UserMonad/index.html">UserMonad</a> : <a href="../../Params/index.html#module-type-Monad">Params.Monad</a>) -&gt; <a href="../../index.html#module-type-Promise">Promise</a><span class="keyword"> with </span><span class="keyword">type </span><a href="For/index.html#type-error">error</a> := <a href="index.html#type-error">error</a><span class="keyword"> and </span><span class="keyword">type </span>a <a href="For/index.html#type-monad">monad</a> := a <a href="For/argument-1-UserMonad/index.html#type-t">UserMonad.t</a></code></div><div class="doc"><p>Create a new result module based on the current one, but wrapped around a monad.</p></div></div></body></html>